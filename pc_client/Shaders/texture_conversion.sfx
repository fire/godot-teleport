//  Copyright (c) 2015-2017 Simul Software Ltd. All rights reserved.
#include "shader_platform.sl"
#include "common.sl"

uniform Texture2D<uint> yTexture;
uniform Texture2D<uint2> uvTexture;
uniform RWTexture2D<float4> rgbTexture; 

float4 Yuv420ToRgbForPixel(uint y, uint u, uint v) 
{
	float fy = float(int(y) - 16);
	float fu = float(int(u) - 128);
	float fv = float(int(v) - 128);

	float maxf = 255.0f;

	float4 rgb;
	rgb.x = clamp((1.16438f * fy) +  (0.0f * fu) + (1.83367f  * fv), 0.0f, maxf);
	rgb.y = clamp((1.16438f * fy) + (-0.218117f * fu) + (-0.545076f * fv), 0.0f, maxf);
	rgb.z = clamp((1.16438f * fy) + (2.16063f  * fu)  +  (0.0f * fv), 0.0f, maxf);
	rgb.w = 1.0f;

	// Convert to unit scale float4needed f or the rgbTexture.
	float toUnitScale = 1.0f / 255.0f;
	rgb.xyz *= toUnitScale;

	return rgb;
}

[numthreads(16, 16, 1)]
shader void CS_NV12ToRGBA(uint3 g : SV_GroupID, uint3 t : SV_GroupThreadID)
{
	uint2 threadID = uint2(g.xy * 16 + t.xy);
	uint W, H;
	rgbTexture.GetDimensions(W, H);

	int2 pos = int2(threadID) * 2;

	if (pos.x >= W || pos.y >= H)
	{
		return;
	}

	int2 uvPos = int2(threadID);

	uint l0 = yTexture.Load(int3(pos, 0));
	uint l1 = yTexture.Load(int3(pos.x + 1, pos.y, 0));
	uint l2 = yTexture.Load(int3(pos.x, pos.y + 1, 0));
	uint l3 = yTexture.Load(int3(pos.x + 1, pos.y + 1, 0));
	uint2 ch = uvTexture.Load(int3(uvPos, 0));

	// All four pixels have their own Y but share the U and V.
	float4 p0, p1, p2, p3;
	p0 = Yuv420ToRgbForPixel(l0, ch.x, ch.y);
	p1 = Yuv420ToRgbForPixel(l1, ch.x, ch.y);
	p2 = Yuv420ToRgbForPixel(l2, ch.x, ch.y);
	p3 = Yuv420ToRgbForPixel(l3, ch.x, ch.y);

	rgbTexture[pos] = p0;
	rgbTexture[int2(pos.x + 1, pos.y)] = p1;
	rgbTexture[int2(pos.x, pos.y + 1)] = p2;
	rgbTexture[int2(pos.x + 1, pos.y + 1)] = p3;
}

technique nv12_to_rgba
{
	pass p0
	{
		SetComputeShader(CompileShader(cs_5_0, CS_NV12ToRGBA()));
	}
}
