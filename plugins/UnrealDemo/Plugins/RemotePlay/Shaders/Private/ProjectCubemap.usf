// (c) 2018-2019 Simul.co

#include "/Engine/Public/Platform.ush"
#include "/Plugin/RemotePlay/Private/Common.ush"

static const float HalfPI = 0.5 * PI;
static const float TwoPI  = 2.0 * PI;

TextureCube InputCubeMap;
SamplerState DefaultSampler;

// The input texture, but as an array of 6 2d faces.
RWTexture2DArray<float4> RWInputCubeAsArray;
RWTexture2D<float4> RWOutputColorTexture;

int2 Offset;

#if DEPTH_STACKED
uint DepthPos;
#endif
#if WRITE_DEPTH
RWTexture2D<float> RWOutputDepthTexture;
#if WRITE_DEPTH_LINEAR
float2 WorldZToDeviceZTransform;
float ConvertToDeviceZ(float SceneDepth)
{
	return 1.0f / ((SceneDepth + WorldZToDeviceZTransform.y) * WorldZToDeviceZTransform.x);
}
#endif // WRITE_DEPTH_LINEAR

#endif // WRITE_DEPTH

[numthreads(THREADGROUP_SIZEX, THREADGROUP_SIZEY, 1)]
void MainCS(uint2 ThreadID : SV_DispatchThreadID)
{
	uint OutputW, OutputH;
	RWOutputColorTexture.GetDimensions(OutputW, OutputH);
#if DEPTH_STACKED
	float2 UV = float2(ThreadID.x / float(OutputW), ThreadID.y / float(DepthPos));
#else
	float2 UV  = float2(ThreadID.x / float(OutputW), ThreadID.y / float(OutputH));
#endif
	float Phi   = UV.x * TwoPI;
	float Theta = UV.y * PI;

	float3 CubeSampleVec = float3(
		sin(Theta) * cos(Phi),
		sin(Theta) * sin(Phi),
		cos(Theta)
	);
	float4 SceneColor = InputCubeMap.SampleLevel(DefaultSampler, CubeSampleVec, 0);
#if WRITE_DEPTH
#if 0//WRITE_DEPTH_LINEAR
	float DepthValue = ConvertToDeviceZ(SceneColor.a);
#else
	float DepthValue = SceneColor.a / 100.0 / 50.0;
#endif // WRITE_DEPTH_LINEAR
#else
	float DepthValue = 0.0;
#endif

	RWOutputColorTexture[int2(ThreadID.x, ThreadID.y)] = float4(PrepareTonemap(SceneColor).rgb, 0);
#if DEPTH_STACKED
	//DepthValue goes from 0 to 1.
	float4 d4 = float4(DepthValue, DepthValue, DepthValue, DepthValue);
	RWOutputColorTexture[int2(ThreadID.x/2,ThreadID.y/2+ DepthPos)] = d4;
	RWOutputColorTexture[int2(OutputW/2+ThreadID.x / 2, ThreadID.y / 2 + DepthPos)] = d4;;
#endif


#if WRITE_DEPTH_TEXTURE
	RWOutputDepthTexture[int2(ThreadID.x, ThreadID.y)] = DepthValue;
#endif // WRITE_DEPTH
}

[numthreads(THREADGROUP_SIZEX, THREADGROUP_SIZEY, 1)]
void DecomposeCS(uint3 ThreadID : SV_DispatchThreadID)
{
	uint InputW, InputH, InputD;
	RWInputCubeAsArray.GetDimensions(InputW, InputH, InputD);
	uint OutputW, OutputH;
	RWOutputColorTexture.GetDimensions(OutputW, OutputH);
	if (ThreadID.x >= OutputW || ThreadID.y >= OutputH)
		return;
	int3 pos = int3(ThreadID);
	int2 FaceOffsets[] = { {0,0},{1,0},{2,0},{0,1},{1,1},{2,1} };
	float4 SceneColor = RWInputCubeAsArray[pos];
	RWOutputColorTexture[int2(ThreadID.x , ThreadID.y ) + Offset + InputW * FaceOffsets[pos.z]] = SceneColor;
}

float PosToDistanceMultiplier(int2 pos, int w)
{
	float h = (w +1.0) / 2.0;
	vec2 diff = (vec2(pos) - vec2(h, h)) *2.0/ vec2(w, w);
	return sqrt(1.0 + dot(diff, diff));
}

float GetDepth(int3 pos, int w)
{
	float m = PosToDistanceMultiplier(pos.xy,w);
	float d = RWInputCubeAsArray[pos].a;
	d *= m;
	return d;
}

[numthreads(THREADGROUP_SIZEX, THREADGROUP_SIZEY, 1)]
void DecomposeDepthCS(uint3 ThreadID : SV_DispatchThreadID)
{
	uint InputW, InputH, InputD;
	RWInputCubeAsArray.GetDimensions(InputW, InputH, InputD);
	uint OutputW, OutputH;
	RWOutputColorTexture.GetDimensions(OutputW, OutputH);
	if (ThreadID.x >= OutputW || ThreadID.y >= OutputH)
		return;
	int3 pos = int3(ThreadID);
	pos.xy *= 2;
	int2 FaceOffsets[] = { {0,0},{1,0},{2,0},{0,1},{1,1},{2,1} };
	float d00 = GetDepth(pos,InputW);
	float d01 = GetDepth(pos+int3(1,0,0), InputW);
	float d10 = GetDepth(pos+int3(0,1,0), InputW);
	float4 DepthValue =  float4(d00, d01, d10, 1.0) / 100.0 / 20.0;

	RWOutputColorTexture[int2(ThreadID.x, ThreadID.y) + Offset + InputW * FaceOffsets[pos.z]/2] = DepthValue;
}
